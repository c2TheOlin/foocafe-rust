

Variables are declared using the "let annotations" by default these are immutable.
You can make them mutable with the "mut" annotation.

Are immutable variables constants? NO - they can be assinged a value by a funaction.

fn main()
{
    let u8: seed = 8; 
    let myvar = fn calculate(seed) { return  seed / 2;};
}

Result type (both generic and specific)
- Ok, Err 
- Error is a wrapper round the error information.

Result type has functions to handle errors such .expect("..")

match function which us similar to a switch case in C#.

All standard unsiged and signed scalar types.
Compound types of array, tuple and vector.
 let tup: (i32, f64, u8) = (500, 6.4, 1);
 let (x, y, z) = tup; //destructuring pattern matching. and also indexed values e.g tup.1

Arrays are fixed lengths and type specific.
let a: [i32; 5] = [1, 2, 3, 4, 5];
index very much like C++ and C# a[0];

Variables are declared using the "let annotations" by default these are immutable.
You can make them mutable with the "mut" annotation.

Snake case - another creature naming.

Statements dont evalute to a value  - let x = y = 5; No No;
Expression dont need a return just end without a semi colon. but can still exit early with return.
Ifs elses are expressions let x = if blah { blah } else { no blah };

loops
while (as normal)
loop-> break and return via value appearing after the break
for element in a.iter() {

collections can be traversed in reveser .rev().
